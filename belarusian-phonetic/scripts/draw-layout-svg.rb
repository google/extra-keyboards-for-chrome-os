# This script eats json mapping from keys to symbols (same as layout
# variable in background.js) and produces layout.svg image. Apart from
# this comment it is 100% generated by Gemini LLM. So code-style-wise
# it is not great (to put it diplomatically), but since it is one-time
# thing, I choose to use it as-is. The resultant drawing is actually
# quite nice.

require 'json'

# --- 1. CONFIGURATION ---
KEY_W = 60
KEY_H = 60
GAP = 5
FONT_SIZE_MAIN = 20
FONT_SIZE_ALT = 14

# Colors
COLOR_KEY_FILL_DEFAULT = "#ffffff"
COLOR_KEY_FILL_MODIFIED = "#f0f9ff" # Light blue for custom keys
COLOR_KEY_STROKE = "#5f6368"        # Chromebook-style dark gray border
STROKE_WIDTH = 1.5

COLOR_TEXT_MAIN = "#202124"    # Google Dark Gray
COLOR_TEXT_ALT = "#d93025"     # Reddish for AltGr (distinctive)
COLOR_TEXT_DEFAULT = "#9aa0a6" # Light Gray for passthrough keys

# --- 2. FALLBACK DATA (Standard US ANSI) ---
US_DEFAULTS = {
  'Backquote' => ['`', '~'],
  'Digit1' => ['1', '!'], 'Digit2' => ['2', '@'], 'Digit3' => ['3', '#'],
  'Digit4' => ['4', '$'], 'Digit5' => ['5', '%'], 'Digit6' => ['6', '^'],
  'Digit7' => ['7', '&'], 'Digit8' => ['8', '*'], 'Digit9' => ['9', '('],
  'Digit0' => ['0', ')'], 'Minus' => ['-', '_'], 'Equal' => ['=', '+'],

  'KeyQ' => ['q', 'Q'], 'KeyW' => ['w', 'W'], 'KeyE' => ['e', 'E'], 'KeyR' => ['r', 'R'],
  'KeyT' => ['t', 'T'], 'KeyY' => ['y', 'Y'], 'KeyU' => ['u', 'U'], 'KeyI' => ['i', 'I'],
  'KeyO' => ['o', 'O'], 'KeyP' => ['p', 'P'],
  'BracketLeft' => ['[', '{'], 'BracketRight' => [']', '}'], 'Backslash' => ['\\', '|'],

  'KeyA' => ['a', 'A'], 'KeyS' => ['s', 'S'], 'KeyD' => ['d', 'D'], 'KeyF' => ['f', 'F'],
  'KeyG' => ['g', 'G'], 'KeyH' => ['h', 'H'], 'KeyJ' => ['j', 'J'], 'KeyK' => ['k', 'K'],
  'KeyL' => ['l', 'L'], 'Semicolon' => [';', ':'], 'Quote' => ["'", '"'],

  'KeyZ' => ['z', 'Z'], 'KeyX' => ['x', 'X'], 'KeyC' => ['c', 'C'], 'KeyV' => ['v', 'V'],
  'KeyB' => ['b', 'B'], 'KeyN' => ['n', 'N'], 'KeyM' => ['m', 'M'],
  'Comma' => [',', '<'], 'Period' => ['.', '>'], 'Slash' => ['/', '?']
}

# --- 3. GEOMETRY (Chromebook Layout) ---
# Total Width Target: 15.0 units
ROWS = [
  # Row 1
  [ ['Backquote', 1], ['Digit1', 1], ['Digit2', 1], ['Digit3', 1], ['Digit4', 1], ['Digit5', 1], ['Digit6', 1], ['Digit7', 1], ['Digit8', 1], ['Digit9', 1], ['Digit0', 1], ['Minus', 1], ['Equal', 1], ['Backspace', 2] ],
  # Row 2
  [ ['Tab', 1.5], ['KeyQ', 1], ['KeyW', 1], ['KeyE', 1], ['KeyR', 1], ['KeyT', 1], ['KeyY', 1], ['KeyU', 1], ['KeyI', 1], ['KeyO', 1], ['KeyP', 1], ['BracketLeft', 1], ['BracketRight', 1], ['Backslash', 1.5] ],
  # Row 3 (Search replaces CapsLock usually, but treating as CapsLock geometry for mapping)
  [ ['CapsLock', 1.75], ['KeyA', 1], ['KeyS', 1], ['KeyD', 1], ['KeyF', 1], ['KeyG', 1], ['KeyH', 1], ['KeyJ', 1], ['KeyK', 1], ['KeyL', 1], ['Semicolon', 1], ['Quote', 1], ['Enter', 2.25] ],
  # Row 4
  [ ['ShiftLeft', 2.25], ['KeyZ', 1], ['KeyX', 1], ['KeyC', 1], ['KeyV', 1], ['KeyB', 1], ['KeyN', 1], ['KeyM', 1], ['Comma', 1], ['Period', 1], ['Slash', 1], ['ShiftRight', 2.75] ],
  # Row 5 (Custom Chromebook Bottom Row: Ctrl, Fn, G, Alt, Space, Compose, Ctrl)
  # Width calc: 1.25 * 6 modifiers = 7.5. Remaining for space = 7.5. Total 15.
  [
    ['ControlLeft', 1.25],
    ['Fn', 1.25],
    ['MetaLeft', 1.25],
    ['AltLeft', 1.25],
    ['Space', 7.5],
    ['AltRight', 1.25],
    ['ControlRight', 1.25]
  ]
]

# --- 4. DATA LOADING ---
layout_file = ARGV[0] || 'layout.json'
layout_data = {}
layout_data = JSON.parse(File.read(layout_file)) if File.exist?(layout_file)

def esc(str)
  return "" if str.nil?
  str.to_s.gsub('&', '&amp;').gsub('<', '&lt;').gsub('>', '&gt;').gsub("'", '&apos;').gsub('"', '&quot;')
end

# --- 5. RENDER LOGIC ---
def draw_key(code, width, x, y, user_data, default_data)
  w_px = (width * KEY_W) + ((width - 1) * GAP)
  h_px = KEY_H

  # Data merging
  final_labels = default_data || []
  is_modified = false
  if user_data && user_data.any? { |val| val != "null" && !val.nil? }
    final_labels = user_data
    is_modified = true
  end

  l1, l2, l3, l4 = final_labels[0], final_labels[1], final_labels[2], final_labels[3]

  # Clean up nulls
  [l1, l2, l3, l4].each_with_index { |v, i| final_labels[i] = nil if v == "null" }
  l1, l2, l3, l4 = final_labels

  # --- CUSTOM LABEL OVERRIDES ---
  is_func = false

  if code == 'MetaLeft' # "G" Key
    l1 = "G"
    is_func = true
  elsif code == 'AltRight' # "Compose" Key
    l1 = "Compose"
    is_func = true
  elsif code == 'Fn'
    l1 = "fn"
    is_func = true
  elsif code == 'CapsLock' # Usually Search on Chromebooks
    l1 = "Search"
    is_func = true
  elsif l1.nil? && l2.nil? && !US_DEFAULTS.key?(code)
    # Generic fallback for Tab, Shift, etc.
    l1 = code.gsub(/(Left|Right|Key)/, '')
    is_func = true
  end

  svg = []

  # Styling
  fill = is_modified ? COLOR_KEY_FILL_MODIFIED : COLOR_KEY_FILL_DEFAULT

  # Draw Keycap
  svg << %Q|<rect x="#{x}" y="#{y}" width="#{w_px}" height="#{h_px}" rx="4" ry="4" fill="#{fill}" stroke="#{COLOR_KEY_STROKE}" stroke-width="#{STROKE_WIDTH}" />|

  # Level 1 (Bottom Left / Centered Func)
  if l1
    if is_func
       # Centered label for function keys
       style = "font-size: 13px; font-weight: bold; fill: #{COLOR_TEXT_MAIN};"
       # Rough centering math
       text_anchor = 'text-anchor="middle"'
       pos_x = x + (w_px / 2)
       pos_y = y + (h_px / 2) + 4
       svg << %Q|<text x="#{pos_x}" y="#{pos_y}" #{text_anchor} style="#{style}">#{esc(l1)}</text>|
    else
       # Standard character positioning
       style_base = is_modified ? "font-weight: bold; fill: #{COLOR_TEXT_MAIN};" : "fill: #{COLOR_TEXT_DEFAULT};"
       style = "font-size: #{FONT_SIZE_MAIN}px; #{style_base}"
       pos_x = x + 7; pos_y = y + h_px - 14
       svg << %Q|<text x="#{pos_x}" y="#{pos_y}" style="#{style}">#{esc(l1)}</text>|
    end
  end

  # Level 2 (Top Left - Shift)
  if l2 && l2 != l1&.upcase
    fill_col = is_modified ? COLOR_TEXT_MAIN : COLOR_TEXT_DEFAULT
    svg << %Q|<text x="#{x + 7}" y="#{y + 20}" style="font-size: #{FONT_SIZE_MAIN}px; fill: #{fill_col};">#{esc(l2)}</text>|
  end

  # Level 3 (Bottom Right - AltGr)
  if l3
    svg << %Q|<text x="#{x + w_px - 5}" y="#{y + h_px - 8}" text-anchor="end" style="font-size: #{FONT_SIZE_ALT}px; fill: #{COLOR_TEXT_ALT};">#{esc(l3)}</text>|
  end

  # Level 4 (Top Right - AltGr+Shift)
  if l4 && l4 != l3&.upcase
     svg << %Q|<text x="#{x + w_px - 5}" y="#{y + 20}" text-anchor="end" style="font-size: #{FONT_SIZE_ALT}px; fill: #{COLOR_TEXT_ALT};">#{esc(l4)}</text>|
  end

  svg.join("\n")
end

# --- 6. EXECUTION ---
canvas_width = (15 * KEY_W) + (14 * GAP) + 20
canvas_height = (5 * KEY_H) + (4 * GAP) + 20

puts %Q|<svg width="#{canvas_width}" height="#{canvas_height}" xmlns="http://www.w3.org/2000/svg">|
puts %Q|<style>text { font-family: 'Roboto', sans-serif; pointer-events: none; }</style>|
puts %Q|<rect width="100%" height="100%" fill="white" />|

current_y = 10

ROWS.each do |row|
  current_x = 10
  row.each do |key_def|
    code, width_u = key_def
    puts draw_key(code, width_u, current_x, current_y, layout_data[code], US_DEFAULTS[code])
    current_x += (width_u * KEY_W) + (width_u > 0 ? GAP : 0) + ((width_u - 1) * GAP)
  end
  current_y += KEY_H + GAP
end

puts "</svg>"
